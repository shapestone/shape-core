
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>basic: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shapestone/shape/examples/basic/main.go (0.0%)</option>
				
				<option value="file1">github.com/shapestone/shape/internal/parser/errors.go (100.0%)</option>
				
				<option value="file2">github.com/shapestone/shape/internal/parser/format.go (100.0%)</option>
				
				<option value="file3">github.com/shapestone/shape/internal/parser/jsonv/parser.go (82.7%)</option>
				
				<option value="file4">github.com/shapestone/shape/internal/parser/jsonv/tokenizer.go (94.1%)</option>
				
				<option value="file5">github.com/shapestone/shape/internal/tokenizer/matchers.go (76.0%)</option>
				
				<option value="file6">github.com/shapestone/shape/internal/tokenizer/numbers.go (90.5%)</option>
				
				<option value="file7">github.com/shapestone/shape/internal/tokenizer/position.go (0.0%)</option>
				
				<option value="file8">github.com/shapestone/shape/internal/tokenizer/stream.go (94.4%)</option>
				
				<option value="file9">github.com/shapestone/shape/internal/tokenizer/text.go (45.7%)</option>
				
				<option value="file10">github.com/shapestone/shape/internal/tokenizer/tokens.go (95.4%)</option>
				
				<option value="file11">github.com/shapestone/shape/pkg/ast/array.go (100.0%)</option>
				
				<option value="file12">github.com/shapestone/shape/pkg/ast/function.go (72.2%)</option>
				
				<option value="file13">github.com/shapestone/shape/pkg/ast/literal.go (91.7%)</option>
				
				<option value="file14">github.com/shapestone/shape/pkg/ast/object.go (52.9%)</option>
				
				<option value="file15">github.com/shapestone/shape/pkg/ast/position.go (100.0%)</option>
				
				<option value="file16">github.com/shapestone/shape/pkg/ast/printer.go (72.9%)</option>
				
				<option value="file17">github.com/shapestone/shape/pkg/ast/serialization.go (83.3%)</option>
				
				<option value="file18">github.com/shapestone/shape/pkg/ast/type.go (100.0%)</option>
				
				<option value="file19">github.com/shapestone/shape/pkg/ast/types.go (100.0%)</option>
				
				<option value="file20">github.com/shapestone/shape/pkg/ast/visitor.go (16.7%)</option>
				
				<option value="file21">github.com/shapestone/shape/pkg/shape/shape.go (94.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "log"

        "github.com/shapestone/shape/internal/parser"
        "github.com/shapestone/shape/pkg/shape"
)

func main() <span class="cov0" title="0">{
        // Example 1: Parse with explicit format
        fmt.Println("=== Example 1: Parse with explicit format ===")
        schema1 := `{
                "id": UUID,
                "name": String(1, 100),
                "email": Email,
                "age": Integer(18, 120)
        }`

        node1, err := shape.Parse(parser.FormatJSONV, schema1)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Parsed successfully! Node type: %s\n", node1.Type())
        fmt.Printf("AST: %s\n\n", node1.String())

        // Example 2: Auto-detect format
        fmt.Println("=== Example 2: Auto-detect format ===")
        schema2 := `{
                "user": {
                        "profile": {
                                "firstName": String(1, 50),
                                "lastName": String(1, 50)
                        },
                        "roles": [String(1, 30)]
                }
        }`

        node2, format, err := shape.ParseAuto(schema2)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Detected format: %s\n", format)
        fmt.Printf("Node type: %s\n", node2.Type())
        fmt.Printf("AST: %s\n\n", node2.String())

        // Example 3: Parse array
        fmt.Println("=== Example 3: Parse array ===")
        schema3 := `[String(1, 30)]`

        node3, err := shape.Parse(parser.FormatJSONV, schema3)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Array schema parsed! Node type: %s\n", node3.Type())
        fmt.Printf("AST: %s\n\n", node3.String())

        // Example 4: Using MustParse
        fmt.Println("=== Example 4: Using MustParse ===")
        schema4 := `{"tags": [String(1, 30)]}`

        node4 := shape.MustParse(parser.FormatJSONV, schema4)
        fmt.Printf("Parsed with MustParse! AST: %s\n", node4.String())</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package parser

import (
        "fmt"

        "github.com/shapestone/shape/pkg/ast"
)

// ParseError represents a parsing error with position information.
type ParseError struct {
        Message  string
        Position ast.Position
        Format   Format
}

// Error implements the error interface.
func (e *ParseError) Error() string <span class="cov8" title="1">{
        if e.Position.Line &gt; 0 &amp;&amp; e.Position.Column &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("error at line %d, column %d: %s",
                        e.Position.Line, e.Position.Column, e.Message)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("parse error: %s", e.Message)</span>
}

// NewSyntaxError creates a syntax error with position.
func NewSyntaxError(pos ast.Position, message string) *ParseError <span class="cov8" title="1">{
        return &amp;ParseError{
                Message:  message,
                Position: pos,
        }
}</span>

// NewUnexpectedTokenError creates an error for unexpected tokens.
func NewUnexpectedTokenError(pos ast.Position, expected, got string) *ParseError <span class="cov8" title="1">{
        message := fmt.Sprintf("expected %s, got %s", expected, got)
        return &amp;ParseError{
                Message:  message,
                Position: pos,
        }
}</span>

// NewUnexpectedEOFError creates an error for unexpected end of file.
func NewUnexpectedEOFError(pos ast.Position, expected string) *ParseError <span class="cov8" title="1">{
        message := fmt.Sprintf("unexpected EOF, expected %s", expected)
        return &amp;ParseError{
                Message:  message,
                Position: pos,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package parser

import (
        "fmt"
        "strings"
        "unicode"
)

// Format represents a validation schema format.
type Format int

const (
        // FormatUnknown indicates the format could not be determined
        FormatUnknown Format = iota
        // FormatJSONV is JSON with validation expressions
        FormatJSONV
        // FormatXMLV is XML with validation expressions
        FormatXMLV
        // FormatPropsV is Properties (key=value) with validation
        FormatPropsV
        // FormatCSVV is CSV with validation headers
        FormatCSVV
        // FormatYAMLV is YAML with validation expressions
        FormatYAMLV
        // FormatTEXTV is Text patterns with validation
        FormatTEXTV
)

// String returns the format name.
func (f Format) String() string <span class="cov8" title="1">{
        switch f </span>{
        case FormatJSONV:<span class="cov8" title="1">
                return "JSONV"</span>
        case FormatXMLV:<span class="cov8" title="1">
                return "XMLV"</span>
        case FormatPropsV:<span class="cov8" title="1">
                return "PropsV"</span>
        case FormatCSVV:<span class="cov8" title="1">
                return "CSVV"</span>
        case FormatYAMLV:<span class="cov8" title="1">
                return "YAMLV"</span>
        case FormatTEXTV:<span class="cov8" title="1">
                return "TEXTV"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// DetectFormat attempts to detect the format from input using heuristics.
// It examines the first non-whitespace character(s) to determine the format.
func DetectFormat(input string) (Format, error) <span class="cov8" title="1">{
        // Trim leading whitespace
        trimmed := strings.TrimLeftFunc(input, unicode.IsSpace)

        if len(trimmed) == 0 </span><span class="cov8" title="1">{
                return FormatUnknown, fmt.Errorf("empty input")
        }</span>

        // Check first character
        <span class="cov8" title="1">firstChar := rune(trimmed[0])

        switch firstChar </span>{
        case '{', '[':<span class="cov8" title="1">
                // JSON-like structure
                return FormatJSONV, nil</span>
        case '&lt;':<span class="cov8" title="1">
                // XML-like structure
                return FormatXMLV, nil</span>
        default:<span class="cov8" title="1">
                // Check for key=value pattern (PropsV)
                if strings.Contains(trimmed, "=") &amp;&amp; !strings.Contains(trimmed, ",") </span><span class="cov8" title="1">{
                        return FormatPropsV, nil
                }</span>

                // Check for CSV (comma-separated values)
                <span class="cov8" title="1">if strings.Contains(trimmed, ",") </span><span class="cov8" title="1">{
                        return FormatCSVV, nil
                }</span>

                // Default to unknown
                <span class="cov8" title="1">return FormatUnknown, fmt.Errorf("unable to detect format from input")</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package jsonv

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/shapestone/shape/internal/parser"
        "github.com/shapestone/shape/internal/tokenizer"
        "github.com/shapestone/shape/pkg/ast"
)

// Parser implements the Parser interface for JSONV format.
type Parser struct {
        tokenizer *tokenizer.Tokenizer
        current   *tokenizer.Token
        hasToken  bool
}

// NewParser creates a new JSONV parser.
func NewParser() *Parser <span class="cov8" title="1">{
        return &amp;Parser{}
}</span>

// Format returns FormatJSONV.
func (p *Parser) Format() parser.Format <span class="cov0" title="0">{
        return parser.FormatJSONV
}</span>

// Parse parses JSONV input and returns the AST.
func (p *Parser) Parse(input string) (ast.SchemaNode, error) <span class="cov8" title="1">{
        // Initialize tokenizer with JSONV matchers
        tok := tokenizer.NewTokenizer(GetMatchers()...)
        tok.Initialize(input)
        p.tokenizer = &amp;tok

        // Load first token
        if err := p.advance(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse root value
        <span class="cov8" title="1">node, err := p.parseValue()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Ensure we consumed all input
        <span class="cov8" title="1">if p.hasToken </span><span class="cov0" title="0">{
                return nil, parser.NewUnexpectedTokenError(
                        p.position(),
                        "end of input",
                        p.current.Kind(),
                )
        }</span>

        <span class="cov8" title="1">return node, nil</span>
}

// advance moves to the next token, skipping whitespace.
func (p *Parser) advance() error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                token, ok := p.tokenizer.NextToken()
                if !ok </span><span class="cov8" title="1">{
                        p.hasToken = false
                        p.current = nil
                        return nil
                }</span>

                // Skip whitespace
                <span class="cov8" title="1">if token.Kind() == TokenWhitespace </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">p.current = token
                p.hasToken = true
                return nil</span>
        }
}

// expect checks if the current token matches the expected kind and advances.
func (p *Parser) expect(tokenKind string) (*tokenizer.Token, error) <span class="cov8" title="1">{
        if !p.hasToken </span><span class="cov8" title="1">{
                return nil, parser.NewUnexpectedEOFError(
                        p.position(),
                        tokenKind,
                )
        }</span>

        <span class="cov8" title="1">if p.current.Kind() != tokenKind </span><span class="cov8" title="1">{
                return nil, parser.NewUnexpectedTokenError(
                        p.position(),
                        tokenKind,
                        p.current.Kind(),
                )
        }</span>

        <span class="cov8" title="1">token := p.current
        p.advance()
        return token, nil</span>
}

// peek returns the current token without advancing.
func (p *Parser) peek() *tokenizer.Token <span class="cov0" title="0">{
        if p.hasToken </span><span class="cov0" title="0">{
                return p.current
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// position returns the current position for error messages.
func (p *Parser) position() ast.Position <span class="cov8" title="1">{
        if p.hasToken </span><span class="cov8" title="1">{
                return ast.Position{
                        Offset: p.current.Offset(),
                        Line:   p.current.Row(),
                        Column: p.current.Column(),
                }
        }</span>
        <span class="cov8" title="1">return ast.Position{
                Line:   p.tokenizer.GetRow(),
                Column: p.tokenizer.GetColumn(),
        }</span>
}

// parseValue dispatches to specific parsers based on token type.
func (p *Parser) parseValue() (ast.SchemaNode, error) <span class="cov8" title="1">{
        if !p.hasToken </span><span class="cov8" title="1">{
                return nil, parser.NewUnexpectedEOFError(p.position(), "value")
        }</span>

        <span class="cov8" title="1">switch p.current.Kind() </span>{
        case TokenObjectStart:<span class="cov8" title="1">
                return p.parseObject()</span>
        case TokenArrayStart:<span class="cov8" title="1">
                return p.parseArray()</span>
        case TokenString:<span class="cov8" title="1">
                return p.parseLiteralString()</span>
        case TokenNumber:<span class="cov8" title="1">
                return p.parseLiteralNumber()</span>
        case TokenTrue, TokenFalse:<span class="cov8" title="1">
                return p.parseLiteralBool()</span>
        case TokenNull:<span class="cov8" title="1">
                return p.parseLiteralNull()</span>
        case TokenFunction:<span class="cov8" title="1">
                return p.parseFunction()</span>
        case TokenIdentifier:<span class="cov8" title="1">
                return p.parseType()</span>
        default:<span class="cov8" title="1">
                return nil, parser.NewUnexpectedTokenError(
                        p.position(),
                        "value",
                        p.current.Kind(),
                )</span>
        }
}

// parseObject parses: { "key": value, ... }
func (p *Parser) parseObject() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()

        // Expect '{'
        if _, err := p.expect(TokenObjectStart); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">properties := make(map[string]ast.SchemaNode)

        // Check for empty object
        if p.hasToken &amp;&amp; p.current.Kind() == TokenObjectEnd </span><span class="cov8" title="1">{
                p.advance()
                return ast.NewObjectNode(properties, pos), nil
        }</span>

        // Parse properties
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // Expect property name (string)
                keyToken, err := p.expect(TokenString)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Extract key from quoted string
                <span class="cov8" title="1">key := p.unquoteString(keyToken.ValueString())

                // Expect ':'
                if _, err := p.expect(TokenColon); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Parse property value
                <span class="cov8" title="1">value, err := p.parseValue()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">properties[key] = value

                // Check for comma or end
                if !p.hasToken </span><span class="cov8" title="1">{
                        return nil, parser.NewUnexpectedEOFError(p.position(), "} or ,")
                }</span>

                <span class="cov8" title="1">if p.current.Kind() == TokenObjectEnd </span><span class="cov8" title="1">{
                        p.advance()
                        break</span>
                }

                <span class="cov8" title="1">if p.current.Kind() == TokenComma </span><span class="cov8" title="1">{
                        p.advance()
                        // After comma, expect another property
                        continue</span>
                }

                <span class="cov0" title="0">return nil, parser.NewUnexpectedTokenError(
                        p.position(),
                        "} or ,",
                        p.current.Kind(),
                )</span>
        }

        <span class="cov8" title="1">return ast.NewObjectNode(properties, pos), nil</span>
}

// parseArray parses: [ elementSchema ]
func (p *Parser) parseArray() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()

        // Expect '['
        if _, err := p.expect(TokenArrayStart); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse element schema
        <span class="cov8" title="1">elementSchema, err := p.parseValue()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Expect ']'
        <span class="cov8" title="1">if _, err := p.expect(TokenArrayEnd); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ast.NewArrayNode(elementSchema, pos), nil</span>
}

// parseLiteralString parses a string literal.
func (p *Parser) parseLiteralString() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()
        token, err := p.expect(TokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Unquote the string
        <span class="cov8" title="1">value := p.unquoteString(token.ValueString())
        return ast.NewLiteralNode(value, pos), nil</span>
}

// parseLiteralNumber parses a number literal.
func (p *Parser) parseLiteralNumber() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()
        token, err := p.expect(TokenNumber)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse number
        <span class="cov8" title="1">str := token.ValueString()
        if strings.Contains(str, ".") || strings.ContainsAny(str, "eE") </span><span class="cov8" title="1">{
                // Float
                value, err := strconv.ParseFloat(str, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, parser.NewSyntaxError(pos, fmt.Sprintf("invalid number: %s", str))
                }</span>
                <span class="cov8" title="1">return ast.NewLiteralNode(value, pos), nil</span>
        } else<span class="cov8" title="1"> {
                // Integer
                value, err := strconv.ParseInt(str, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, parser.NewSyntaxError(pos, fmt.Sprintf("invalid number: %s", str))
                }</span>
                <span class="cov8" title="1">return ast.NewLiteralNode(value, pos), nil</span>
        }
}

// parseLiteralBool parses a boolean literal.
func (p *Parser) parseLiteralBool() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()

        if p.current.Kind() == TokenTrue </span><span class="cov8" title="1">{
                p.advance()
                return ast.NewLiteralNode(true, pos), nil
        }</span> else<span class="cov8" title="1"> if p.current.Kind() == TokenFalse </span><span class="cov8" title="1">{
                p.advance()
                return ast.NewLiteralNode(false, pos), nil
        }</span>

        <span class="cov0" title="0">return nil, parser.NewUnexpectedTokenError(pos, "true or false", p.current.Kind())</span>
}

// parseLiteralNull parses a null literal.
func (p *Parser) parseLiteralNull() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()
        _, err := p.expect(TokenNull)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ast.NewLiteralNode(nil, pos), nil</span>
}

// parseFunction parses: FunctionName(arg1, arg2, ...)
func (p *Parser) parseFunction() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()
        token, err := p.expect(TokenFunction)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse function call: "FunctionName(args)"
        <span class="cov8" title="1">str := token.ValueString()

        // Find opening paren
        openParen := strings.Index(str, "(")
        if openParen == -1 </span><span class="cov0" title="0">{
                return nil, parser.NewSyntaxError(pos, "malformed function call")
        }</span>

        // Extract function name
        <span class="cov8" title="1">name := str[:openParen]

        // Extract arguments (between parens)
        argsStr := str[openParen+1 : len(str)-1]

        // Parse arguments
        args, err := p.parseArguments(argsStr, pos)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ast.NewFunctionNode(name, args, pos), nil</span>
}

// parseArguments parses function arguments from a string.
func (p *Parser) parseArguments(argsStr string, pos ast.Position) ([]interface{}, error) <span class="cov8" title="1">{
        if strings.TrimSpace(argsStr) == "" </span><span class="cov8" title="1">{
                return []interface{}{}, nil
        }</span>

        // Split by comma (simple split, doesn't handle nested strings with commas)
        <span class="cov8" title="1">parts := p.splitArguments(argsStr)
        args := make([]interface{}, 0, len(parts))

        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)

                // Check for number with + suffix (e.g., "5+")
                if strings.HasSuffix(part, "+") &amp;&amp; len(part) &gt; 1 </span><span class="cov8" title="1">{
                        numPart := part[:len(part)-1]
                        if num, err := strconv.ParseInt(numPart, 10, 64); err == nil </span><span class="cov8" title="1">{
                                args = append(args, num)
                                args = append(args, "+")
                                continue</span>
                        }
                }

                // Check for special symbols
                <span class="cov8" title="1">if part == "+" </span><span class="cov0" title="0">{
                        args = append(args, "+")
                        continue</span>
                }

                // Check for string literal
                <span class="cov8" title="1">if strings.HasPrefix(part, `"`) &amp;&amp; strings.HasSuffix(part, `"`) </span><span class="cov8" title="1">{
                        value := p.unquoteString(part)
                        args = append(args, value)
                        continue</span>
                }

                // Check for number
                <span class="cov8" title="1">if num, err := strconv.ParseInt(part, 10, 64); err == nil </span><span class="cov8" title="1">{
                        args = append(args, num)
                        continue</span>
                }

                <span class="cov8" title="1">if num, err := strconv.ParseFloat(part, 64); err == nil </span><span class="cov0" title="0">{
                        args = append(args, num)
                        continue</span>
                }

                // Check for boolean
                <span class="cov8" title="1">if part == "true" </span><span class="cov0" title="0">{
                        args = append(args, true)
                        continue</span>
                }
                <span class="cov8" title="1">if part == "false" </span><span class="cov0" title="0">{
                        args = append(args, false)
                        continue</span>
                }

                // Check for null
                <span class="cov8" title="1">if part == "null" </span><span class="cov0" title="0">{
                        args = append(args, nil)
                        continue</span>
                }

                <span class="cov8" title="1">return nil, parser.NewSyntaxError(pos, fmt.Sprintf("invalid function argument: %s", part))</span>
        }

        <span class="cov8" title="1">return args, nil</span>
}

// splitArguments splits comma-separated arguments, respecting quoted strings.
func (p *Parser) splitArguments(s string) []string <span class="cov8" title="1">{
        var parts []string
        var current strings.Builder
        inString := false
        escaped := false

        for _, r := range s </span><span class="cov8" title="1">{
                if escaped </span><span class="cov0" title="0">{
                        current.WriteRune(r)
                        escaped = false
                        continue</span>
                }

                <span class="cov8" title="1">if r == '\\' </span><span class="cov0" title="0">{
                        current.WriteRune(r)
                        escaped = true
                        continue</span>
                }

                <span class="cov8" title="1">if r == '"' </span><span class="cov8" title="1">{
                        current.WriteRune(r)
                        inString = !inString
                        continue</span>
                }

                <span class="cov8" title="1">if r == ',' &amp;&amp; !inString </span><span class="cov8" title="1">{
                        parts = append(parts, current.String())
                        current.Reset()
                        continue</span>
                }

                <span class="cov8" title="1">current.WriteRune(r)</span>
        }

        <span class="cov8" title="1">if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                parts = append(parts, current.String())
        }</span>

        <span class="cov8" title="1">return parts</span>
}

// parseType parses a type identifier (e.g., UUID, Email).
func (p *Parser) parseType() (ast.SchemaNode, error) <span class="cov8" title="1">{
        pos := p.position()
        token, err := p.expect(TokenIdentifier)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ast.NewTypeNode(token.ValueString(), pos), nil</span>
}

// unquoteString removes surrounding quotes and handles escape sequences.
func (p *Parser) unquoteString(s string) string <span class="cov8" title="1">{
        if len(s) &lt; 2 </span><span class="cov0" title="0">{
                return s
        }</span>

        // Remove surrounding quotes
        <span class="cov8" title="1">s = s[1 : len(s)-1]

        // Handle escape sequences
        s = strings.ReplaceAll(s, `\"`, `"`)
        s = strings.ReplaceAll(s, `\\`, `\`)
        s = strings.ReplaceAll(s, `\n`, "\n")
        s = strings.ReplaceAll(s, `\r`, "\r")
        s = strings.ReplaceAll(s, `\t`, "\t")

        return s</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package jsonv

import (
        "unicode"

        "github.com/shapestone/shape/internal/tokenizer"
)

// Token kinds for JSONV
const (
        TokenObjectStart = "ObjectStart"
        TokenObjectEnd   = "ObjectEnd"
        TokenArrayStart  = "ArrayStart"
        TokenArrayEnd    = "ArrayEnd"
        TokenColon       = "Colon"
        TokenComma       = "Comma"
        TokenString      = "String"
        TokenNumber      = "Number"
        TokenTrue        = "True"
        TokenFalse       = "False"
        TokenNull        = "Null"
        TokenIdentifier  = "Identifier"
        TokenFunction    = "Function"
        TokenWhitespace  = "Whitespace"
)

// identifierMatcher matches type identifiers: UUID, Email, ISO-8601
// Pattern: [A-Z][A-Za-z0-9-]*
func identifierMatcher(stream tokenizer.Stream) *tokenizer.Token <span class="cov8" title="1">{
        // Must start with uppercase letter
        first, ok := stream.NextChar()
        if !ok || !unicode.IsUpper(first) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">value := []rune{first}

        // Continue with letters, digits, or hyphens
        for </span><span class="cov8" title="1">{
                r, ok := stream.NextChar()
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' </span><span class="cov8" title="1">{
                        value = append(value, r)
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">return tokenizer.NewToken(TokenIdentifier, value)</span>
}

// functionMatcher matches function calls: Integer(1, 100)
// Pattern: Identifier '(' arguments ')'
func functionMatcher(stream tokenizer.Stream) *tokenizer.Token <span class="cov8" title="1">{
        // Must start with uppercase letter (function name)
        first, ok := stream.NextChar()
        if !ok || !unicode.IsUpper(first) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">value := []rune{first}

        // Continue with letters/digits/hyphens until we hit '('
        foundParen := false
        for </span><span class="cov8" title="1">{
                r, ok := stream.NextChar()
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if r == '(' </span><span class="cov8" title="1">{
                        value = append(value, r)
                        foundParen = true
                        break</span>
                } else<span class="cov8" title="1"> if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '-' </span><span class="cov8" title="1">{
                        value = append(value, r)
                }</span> else<span class="cov8" title="1"> {
                        return nil
                }</span>
        }

        <span class="cov8" title="1">if !foundParen </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Now consume everything until we find the matching ')'
        <span class="cov8" title="1">parenDepth := 1
        for </span><span class="cov8" title="1">{
                r, ok := stream.NextChar()
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">value = append(value, r)

                if r == '(' </span><span class="cov8" title="1">{
                        parenDepth++
                }</span> else<span class="cov8" title="1"> if r == ')' </span><span class="cov8" title="1">{
                        parenDepth--
                        if parenDepth == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return tokenizer.NewToken(TokenFunction, value)</span>
}

// stringMatcher matches JSON string literals: "text"
func stringMatcher(stream tokenizer.Stream) *tokenizer.Token <span class="cov8" title="1">{
        // Must start with double quote
        first, ok := stream.NextChar()
        if !ok || first != '"' </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">value := []rune{first}
        escaped := false

        for </span><span class="cov8" title="1">{
                r, ok := stream.NextChar()
                if !ok </span><span class="cov8" title="1">{
                        // Unterminated string
                        return nil
                }</span>

                <span class="cov8" title="1">value = append(value, r)

                if escaped </span><span class="cov8" title="1">{
                        escaped = false
                        continue</span>
                }

                <span class="cov8" title="1">if r == '\\' </span><span class="cov8" title="1">{
                        escaped = true
                        continue</span>
                }

                <span class="cov8" title="1">if r == '"' </span><span class="cov8" title="1">{
                        // End of string
                        break</span>
                }
        }

        <span class="cov8" title="1">return tokenizer.NewToken(TokenString, value)</span>
}

// numberMatcher matches JSON numbers: 42, -3.14, 1.5e10
func numberMatcher(stream tokenizer.Stream) *tokenizer.Token <span class="cov8" title="1">{
        value := []rune{}

        // Optional minus sign
        r, ok := stream.NextChar()
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if r == '-' </span><span class="cov8" title="1">{
                value = append(value, r)
                r, ok = stream.NextChar()
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        // Must have at least one digit
        <span class="cov8" title="1">if !unicode.IsDigit(r) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Integer part
        <span class="cov8" title="1">if r == '0' </span><span class="cov8" title="1">{
                value = append(value, r)
        }</span> else<span class="cov8" title="1"> {
                value = append(value, r)
                for </span><span class="cov8" title="1">{
                        r, ok = stream.NextChar()
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if unicode.IsDigit(r) </span><span class="cov8" title="1">{
                                value = append(value, r)
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
        }

        // Optional decimal part
        <span class="cov8" title="1">if ok &amp;&amp; r == '.' </span><span class="cov8" title="1">{
                value = append(value, r)
                foundDigit := false
                for </span><span class="cov8" title="1">{
                        r, ok = stream.NextChar()
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if unicode.IsDigit(r) </span><span class="cov8" title="1">{
                                value = append(value, r)
                                foundDigit = true
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !foundDigit </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // Optional exponent part
        <span class="cov8" title="1">if ok &amp;&amp; (r == 'e' || r == 'E') </span><span class="cov8" title="1">{
                value = append(value, r)
                r, ok = stream.NextChar()
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Optional sign
                <span class="cov8" title="1">if r == '+' || r == '-' </span><span class="cov8" title="1">{
                        value = append(value, r)
                        r, ok = stream.NextChar()
                        if !ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }

                // Must have at least one digit
                <span class="cov8" title="1">if !unicode.IsDigit(r) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">value = append(value, r)
                for </span><span class="cov8" title="1">{
                        r, ok = stream.NextChar()
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if unicode.IsDigit(r) </span><span class="cov8" title="1">{
                                value = append(value, r)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return tokenizer.NewToken(TokenNumber, value)</span>
}

// GetMatchers returns all matchers for JSONV tokenization in priority order.
func GetMatchers() []tokenizer.Matcher <span class="cov8" title="1">{
        return []tokenizer.Matcher{
                // Whitespace (built-in, skip)
                tokenizer.WhiteSpaceMatcher,

                // Delimiters (single characters)
                tokenizer.CharMatcherFunc(TokenObjectStart, '{'),
                tokenizer.CharMatcherFunc(TokenObjectEnd, '}'),
                tokenizer.CharMatcherFunc(TokenArrayStart, '['),
                tokenizer.CharMatcherFunc(TokenArrayEnd, ']'),
                tokenizer.CharMatcherFunc(TokenColon, ':'),
                tokenizer.CharMatcherFunc(TokenComma, ','),

                // Keywords (must come before identifier to avoid conflicts)
                tokenizer.StringMatcherFunc(TokenTrue, "true"),
                tokenizer.StringMatcherFunc(TokenFalse, "false"),
                tokenizer.StringMatcherFunc(TokenNull, "null"),

                // String literals
                stringMatcher,

                // Numbers
                numberMatcher,

                // Functions (must come before identifier)
                functionMatcher,

                // Identifiers (type names)
                identifierMatcher,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package tokenizer

import (
        "unicode"
)

//
// Built-in Matchers - Common token matchers for various use cases
//

// WhiteSpaceMatcher consumes all consecutive whitespace and yields a Whitespace token.
// Returns nil if no whitespace is found.
func WhiteSpaceMatcher(stream Stream) *Token <span class="cov8" title="1">{
        var value []rune
        for </span><span class="cov8" title="1">{
                if r, ok := stream.NextChar(); ok </span><span class="cov8" title="1">{
                        if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                                value = append(value, r)
                                continue</span>
                        }
                }
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">if len(value) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return NewToken(`Whitespace`, value)</span>
}

// CharMatcherFunc creates a matcher that matches a single character and returns a token.
// The tokenName parameter specifies the token kind.
func CharMatcherFunc(tokenName string, char rune) Matcher <span class="cov0" title="0">{
        return func(stream Stream) *Token </span><span class="cov0" title="0">{
                if r, ok := stream.NextChar(); ok &amp;&amp; r == char </span><span class="cov0" title="0">{
                        return NewToken(tokenName, []rune{char})
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// StringMatcherFunc creates a matcher that matches a literal string and returns a token.
// The tokenName parameter specifies the token kind.
func StringMatcherFunc(tokenName string, literal string) Matcher <span class="cov8" title="1">{
        var rLiteral = []rune(literal)
        return func(stream Stream) *Token </span><span class="cov8" title="1">{
                var value []rune

                for _, ch := range rLiteral </span><span class="cov8" title="1">{
                        if r, ok := stream.NextChar(); ok &amp;&amp; r == ch </span><span class="cov8" title="1">{
                                value = append(value, r)
                                continue</span>
                        }
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov8" title="1">if len(value) != len(rLiteral) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return NewToken(tokenName, value)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package tokenizer

import "math"

//
// Number Utilities - Functions for numeric operations
//

// NearlyEqual compares two float64 numbers and returns true if they are nearly equal
// within the specified epsilon tolerance.
func NearlyEqual(a float64, b float64, epsilon float64) bool <span class="cov8" title="1">{
        // already equal?
        if a == b </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">diff := math.Abs(a - b)
        if a == 0.0 || b == 0.0 || diff &lt; math.SmallestNonzeroFloat64 </span><span class="cov0" title="0">{
                return diff &lt; epsilon*math.SmallestNonzeroFloat64
        }</span>

        <span class="cov8" title="1">return diff/(math.Abs(a)+math.Abs(b)) &lt; epsilon</span>
}

// Difference returns the absolute difference between two float64 numbers.
func Difference(a float64, b float64) float64 <span class="cov8" title="1">{
        return math.Abs(a - b)
}</span>

// MaxInt returns the maximum of two integers.
func MaxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// MinInt returns the minimum of two integers.
func MinInt(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// PowInt calculates m to the n-th power for integers.
func PowInt(m, n int64) int64 <span class="cov8" title="1">{
        if n == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>

        <span class="cov8" title="1">if n == 1 </span><span class="cov8" title="1">{
                return m
        }</span>

        <span class="cov8" title="1">result := m
        for i := int64(2); i &lt;= n; i++ </span><span class="cov8" title="1">{
                result *= m
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package tokenizer

import "fmt"

//
// Position - Position tracking for tokens and streams
//

// Position represents a location in the source text.
type Position struct {
        Offset int // Byte offset (0-indexed)
        Line   int // Line number (1-indexed)
        Column int // Column number (1-indexed)
}

// NewPosition creates a new Position with the given offset, line, and column.
func NewPosition(offset, line, column int) Position <span class="cov0" title="0">{
        return Position{
                Offset: offset,
                Line:   line,
                Column: column,
        }
}</span>

// IsValid returns true if the position has been set (not default -1 values).
func (p Position) IsValid() bool <span class="cov0" title="0">{
        return p.Offset &gt;= 0 &amp;&amp; p.Line &gt; 0 &amp;&amp; p.Column &gt; 0
}</span>

// String returns a string representation of the position.
func (p Position) String() string <span class="cov0" title="0">{
        if !p.IsValid() </span><span class="cov0" title="0">{
                return "&lt;unknown position&gt;"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("line %d, column %d", p.Line, p.Column)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package tokenizer

import (
        "github.com/google/uuid"
)

//
// Stream - Stream abstraction with UTF-8 support and position tracking
//

// Stream defines the interface for a character stream with position tracking.
// It provides UTF-8 support, character peeking/fetching, and pattern matching capabilities.
type Stream interface {
        Clone() Stream
        Match(cs Stream)
        PeekChar() (rune, bool)
        NextChar() (rune, bool)
        MatchChars([]rune) bool
        IsEos() bool
        GetRow() int
        GetOffset() int
        GetColumn() int
        Reset()
}

// NewStream creates a new stream instance from the provided string.
// The stream supports UTF-8 encoding and tracks position (offset, line, column).
func NewStream(str string) Stream <span class="cov8" title="1">{
        runes := []rune(str)
        return &amp;streamImpl{
                uuid:   uuid.New(),
                data:   runes,
                length: len(runes),
                location: location{
                        cursor: 0,
                        row:    1,
                        column: 1,
                },
        }
}</span>

// streamImpl is the internal implementation of the Stream interface.
type streamImpl struct {
        uuid     uuid.UUID
        data     []rune
        length   int
        location location
}

// location holds position information within the stream.
type location struct {
        cursor int // byte offset
        row    int // line number (1-indexed)
        column int // column number (1-indexed)
}

// Clone creates a copy of the stream for backtracking support.
func (s *streamImpl) Clone() Stream <span class="cov8" title="1">{
        return &amp;streamImpl{
                uuid:     s.uuid,
                data:     s.data,
                length:   s.length,
                location: s.location,
        }
}</span>

// Match updates this stream's location to match another stream's location.
// Both streams must be clones of each other (same UUID).
func (s *streamImpl) Match(other Stream) <span class="cov8" title="1">{
        otherImpl := other.(*streamImpl)
        if s.uuid != otherImpl.uuid </span><span class="cov0" title="0">{
                panic("trying to match two different streams")</span>
        }
        <span class="cov8" title="1">s.location = otherImpl.location</span>
}

// PeekChar returns the next rune without advancing the stream.
func (s *streamImpl) PeekChar() (rune, bool) <span class="cov8" title="1">{
        if s.IsEos() </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">r := s.data[s.location.cursor]
        return r, true</span>
}

// NextChar reads and returns the next rune, advancing the stream position.
// Automatically tracks newlines for row/column position.
func (s *streamImpl) NextChar() (rune, bool) <span class="cov8" title="1">{
        if s.IsEos() </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">r := s.data[s.location.cursor]
        s.location.cursor += 1
        s.location.column += 1
        if r == '\n' </span><span class="cov8" title="1">{
                s.location.row += 1
                s.location.column = 1
        }</span>
        <span class="cov8" title="1">return r, true</span>
}

// MatchChars attempts to match a rune sequence against the stream.
// If successful, the stream is advanced. If not, the stream position is unchanged.
func (s *streamImpl) MatchChars(match []rune) bool <span class="cov8" title="1">{
        origLocation := s.location
        for _, mr := range match </span><span class="cov8" title="1">{
                sr, ok := s.NextChar()
                if !ok || mr != sr </span><span class="cov8" title="1">{
                        s.location = origLocation
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsEos returns true if the cursor has reached the end of stream.
func (s *streamImpl) IsEos() bool <span class="cov8" title="1">{
        return s.location.cursor &gt;= s.length
}</span>

// GetOffset returns the current byte offset within the stream.
func (s *streamImpl) GetOffset() int <span class="cov8" title="1">{
        return s.location.cursor
}</span>

// GetRow returns the current line number (1-indexed).
func (s *streamImpl) GetRow() int <span class="cov8" title="1">{
        return s.location.row
}</span>

// GetColumn returns the current column number (1-indexed).
func (s *streamImpl) GetColumn() int <span class="cov8" title="1">{
        return s.location.column
}</span>

// Reset resets the stream to the beginning (offset 0, row 1, column 1).
func (s *streamImpl) Reset() <span class="cov0" title="0">{
        s.location.cursor = 0
        s.location.row = 1
        s.location.column = 1
}</span>

//
// Pattern Matching - Higher-order functions for composing stream matchers
//

// Pattern is a function type that matches patterns in a stream.
// It returns the matched runes and a success flag.
// The stream is mutated only if the match succeeds.
//
// Pattern matchers can be composed using higher-order functions like:
// - Sequence: matches patterns in order
// - OneOf: matches the first successful pattern
// - Optional: matches if possible, but always succeeds
type Pattern func(stream Stream) ([]rune, bool)

// CharMatcher creates a pattern that matches a single character.
func CharMatcher(char rune) Pattern <span class="cov8" title="1">{
        return func(stream Stream) ([]rune, bool) </span><span class="cov8" title="1">{
                if r, ok := stream.NextChar(); ok &amp;&amp; r == char </span><span class="cov8" title="1">{
                        return []rune{char}, true
                }</span>
                <span class="cov8" title="1">return nil, false</span>
        }
}

// StringMatcher creates a pattern that matches a literal string.
func StringMatcher(literal string) Pattern <span class="cov8" title="1">{
        var rLiteral = []rune(literal)
        return func(stream Stream) ([]rune, bool) </span><span class="cov8" title="1">{
                var value []rune

                for _, ch := range rLiteral </span><span class="cov8" title="1">{
                        if r, ok := stream.NextChar(); ok &amp;&amp; r == ch </span><span class="cov8" title="1">{
                                value = append(value, r)
                                continue</span>
                        }
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">if len(value) != len(rLiteral) </span><span class="cov8" title="1">{
                        return nil, false
                }</span>
                <span class="cov8" title="1">return value, true</span>
        }
}

// Sequence applies patterns sequentially. All must succeed for success.
func Sequence(patterns ...Pattern) Pattern <span class="cov8" title="1">{
        return func(stream Stream) ([]rune, bool) </span><span class="cov8" title="1">{
                var value []rune
                for _, pattern := range patterns </span><span class="cov8" title="1">{
                        ra, ok := pattern(stream)
                        if !ok </span><span class="cov8" title="1">{
                                return nil, false
                        }</span>
                        <span class="cov8" title="1">value = append(value, ra...)</span>
                }
                <span class="cov8" title="1">return value, true</span>
        }
}

// OneOf tries patterns in order and returns the first match.
// Uses backtracking (stream cloning) to try each pattern.
func OneOf(patterns ...Pattern) Pattern <span class="cov8" title="1">{
        return func(stream Stream) ([]rune, bool) </span><span class="cov8" title="1">{
                for _, pattern := range patterns </span><span class="cov8" title="1">{
                        cs := stream.Clone() // enable backtracking
                        ra, ok := pattern(cs)
                        if ok </span><span class="cov8" title="1">{
                                stream.Match(cs) // update parent stream
                                return ra, true
                        }</span>
                }
                <span class="cov8" title="1">return nil, false</span>
        }
}

// Optional tries to match a pattern but always succeeds.
// Uses backtracking if the pattern doesn't match.
func Optional(pattern Pattern) Pattern <span class="cov8" title="1">{
        return func(stream Stream) ([]rune, bool) </span><span class="cov8" title="1">{
                cs := stream.Clone()
                ra, ok := pattern(cs)
                if ok </span><span class="cov8" title="1">{
                        stream.Match(cs)
                        return ra, true
                }</span>
                <span class="cov8" title="1">return nil, true</span> // always succeeds
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package tokenizer

import (
        "regexp"
        "strings"
        "unicode/utf8"
)

//
// Text Utilities - Functions for text manipulation and comparison
//

// Regex patterns for text processing
var (
        stripMarginGroup  = regexp.MustCompile(`(?m)^[ \t]*\|(.*)(?:\n|$)`)
        stripColumnGroup  = regexp.MustCompile(`(?m)^[ \t]*\|(.*)(?:\|[ \t]*\n|\|[ \t]*$)`)
        reLastSpace       = regexp.MustCompile(` $`)
        reLastTab         = regexp.MustCompile(`\t$`)
        reTrailingWS      = regexp.MustCompile(`[\n\r\t ]*$`)
        reSpaces          = regexp.MustCompile(`[\t ]$`)
        reTab             = regexp.MustCompile(`\t`)
        reSpace           = regexp.MustCompile(` `)
        reNewline         = regexp.MustCompile(`\n`)
        reReturn          = regexp.MustCompile(`\r`)
        reFormFeed        = regexp.MustCompile(`\f`)
)

// StripMargin lets you define multiline strings where each line is prepended
// with optional whitespace and a pipeline symbol.
//
// Example:
//
//        StripMargin(`
//          |line 1
//          |line 2
//        `)
func StripMargin(s string) string <span class="cov8" title="1">{
        ms := stripMarginGroup.FindAllStringSubmatch(s, -1)
        if ms == nil </span><span class="cov0" title="0">{
                return ``
        }</span>

        <span class="cov8" title="1">lines := ``
        for idx, m := range ms </span><span class="cov8" title="1">{
                if idx &gt; 0 </span><span class="cov8" title="1">{
                        lines += "\n"
                }</span>
                <span class="cov8" title="1">lines += m[1]</span>
        }

        <span class="cov8" title="1">return lines</span>
}

// StripColumn lets you define multiline strings where each line is enclosed
// by pipeline symbols with optional whitespace.
//
// Example:
//
//        StripColumn(`
//          |line 1|
//          |line 2|
//        `)
func StripColumn(s string) string <span class="cov0" title="0">{
        ms := stripColumnGroup.FindAllStringSubmatch(s, -1)
        if ms == nil </span><span class="cov0" title="0">{
                return ``
        }</span>

        <span class="cov0" title="0">lines := ``
        for idx, m := range ms </span><span class="cov0" title="0">{
                if idx &gt; 0 </span><span class="cov0" title="0">{
                        lines += "\n"
                }</span>
                <span class="cov0" title="0">lines += m[1]</span>
        }

        <span class="cov0" title="0">return lines</span>
}

// Diff compares two strings and outputs a diff format.
// Returns the diff string and true if the strings matched.
func Diff(expected string, actual string) (string, bool) <span class="cov8" title="1">{
        expectedArr := showTabsArray(strings.Split(expected, "\n"))
        expectedWidth := len("Expected")
        for _, s := range expectedArr </span><span class="cov8" title="1">{
                if expectedWidth &lt; len(s) </span><span class="cov8" title="1">{
                        expectedWidth = len(s)
                }</span>
        }

        <span class="cov8" title="1">actualArr := showTabsArray(strings.Split(actual, "\n"))
        actualWidth := len("Actual")
        for _, s := range actualArr </span><span class="cov8" title="1">{
                if actualWidth &lt; len(s) </span><span class="cov8" title="1">{
                        actualWidth = len(s)
                }</span>
        }
        <span class="cov8" title="1">width := maxInt(expectedWidth, actualWidth)

        minVal := minInt(len(expectedArr), len(actualArr))
        var sb strings.Builder
        status := true
        sb.WriteString(Pad("Expected", width) + ` | ` + Pad("Actual", width) + "\n")
        sb.WriteString(strings.Repeat(`-`, width) + ` | ` + strings.Repeat(`-`, width) + "\n")
        for i := 0; i &lt; minVal; i++ </span><span class="cov8" title="1">{
                if expectedArr[i] == actualArr[i] </span><span class="cov8" title="1">{
                        sb.WriteString(Pad(expectedArr[i], width) + ` | ` + Pad(actualArr[i], width) + "\n")
                }</span> else<span class="cov0" title="0"> if expectedArr[i] != actualArr[i] </span><span class="cov0" title="0">{
                        expected, actual := SpaceDiff(expectedArr[i], actualArr[i])
                        sb.WriteString(Pad(expected, width) + "  " + Pad(actual, width) + "\n")
                        sd := StringDiff(expectedArr[i], actualArr[i])
                        sb.WriteString(Pad(sd, width) + `   ` + Pad(sd, width) + "\n")
                        return sb.String(), false
                }</span>
        }
        <span class="cov8" title="1">if len(expectedArr) &gt; len(actualArr) </span><span class="cov0" title="0">{
                expectedStr := expectedArr[minVal]
                actualStr := ``
                if utf8.RuneCountInString(expectedStr) == 0 </span><span class="cov0" title="0">{
                        expectedStr = ``
                }</span>
                <span class="cov0" title="0">sb.WriteString(Pad(expectedStr, width) + "  " + Pad(actualStr, width) + "\n")
                status = false</span>
        } else<span class="cov8" title="1"> if len(expectedArr) &lt; len(actualArr) </span><span class="cov0" title="0">{
                expectedStr := ``
                actualStr := actualArr[minVal]
                if utf8.RuneCountInString(actualStr) == 0 </span><span class="cov0" title="0">{
                        actualStr = ``
                }</span>
                <span class="cov0" title="0">sb.WriteString(Pad(expectedStr, width) + "  " + Pad(actualStr, width) + "\n")
                status = false</span>
        }
        <span class="cov8" title="1">return sb.String(), status</span>
}

// Pad performs right space padding on a string to reach the specified length.
func Pad(str string, length int) string <span class="cov8" title="1">{
        rc := length - utf8.RuneCountInString(str)
        return str + strings.Repeat(` `, rc)
}</span>

// SpaceDiff compares two strings and highlights invisible whitespace differences.
func SpaceDiff(a, b string) (string, string) <span class="cov0" title="0">{
        ar := []rune(a)
        br := []rune(b)
        sl := minInt(len(ar), len(br))
        i := 0
        for ; i &lt; sl; i++ </span><span class="cov0" title="0">{
                if ar[i] != br[i] </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">as := showTabsAndSpaces(ar, i)
        bs := showTabsAndSpaces(br, i)
        return string(as), string(bs)</span>
}

func showTabsAndSpaces(ra []rune, i int) []rune <span class="cov0" title="0">{
        for j := i - 1; j &gt;= 0; j-- </span><span class="cov0" title="0">{
                if !isInvisible(ra[j]) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">ra[j] = showInvisible(ra[j])</span>
        }
        <span class="cov0" title="0">for j := i; j &lt; len(ra); j++ </span><span class="cov0" title="0">{
                if !isInvisible(ra[j]) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">ra[j] = showInvisible(ra[j])</span>
        }
        <span class="cov0" title="0">return ra</span>
}

func isInvisible(r rune) bool <span class="cov0" title="0">{
        switch r </span>{
        case ' ':<span class="cov0" title="0">
                return true</span>
        case '\t':<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func showInvisible(r rune) rune <span class="cov0" title="0">{
        switch r </span>{
        case ' ':<span class="cov0" title="0">
                return ''</span>
        case '\t':<span class="cov0" title="0">
                return ''</span>
        default:<span class="cov0" title="0">
                return r</span>
        }
}

// StringDiff returns a visual indicator showing where two strings differ.
func StringDiff(a, b string) string <span class="cov0" title="0">{
        ar := []rune(a)
        br := []rune(b)
        ml := minInt(len(ar), len(br))
        i := 0
        for i &lt; ml </span><span class="cov0" title="0">{
                if ar[i] != br[i] </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">i++</span>
        }
        <span class="cov0" title="0">return strings.Repeat(" ", i) + ""</span>
}

func showTabsArray(orig []string) []string <span class="cov8" title="1">{
        arr := make([]string, len(orig))

        for i, str := range orig </span><span class="cov8" title="1">{
                arr[i] = showTabs(str)
        }</span>

        <span class="cov8" title="1">return arr</span>
}

func showTabs(str string) string <span class="cov8" title="1">{
        str = reTab.ReplaceAllString(str, "")
        return str
}</span>

// Flatten converts whitespace characters to their escaped string representations.
func Flatten(str string) string <span class="cov0" title="0">{
        str = strings.Replace(str, `%`, `%%`, -1)
        str = reNewline.ReplaceAllString(str, `\n`)
        str = reReturn.ReplaceAllString(str, `\r`)
        str = reTab.ReplaceAllString(str, `\t`)
        str = reFormFeed.ReplaceAllString(str, `\f`)
        return str
}</span>

// FitString will shorten or pad the input string to the defined length.
// - If the input string is shorter than the defined length, it returns a padded string.
// - If the input string length equals the defined length, it returns the original string.
// - If the input string is longer, it returns "left ... right" format.
func FitString(str string, length int) string <span class="cov8" title="1">{
        str = strings.Replace(str, `%`, `%%`, -1)
        runeStr := []rune(str)
        strLen := len(runeStr)
        if strLen == length </span><span class="cov0" title="0">{
                return str
        }</span> else<span class="cov8" title="1"> if strLen &lt;= length </span><span class="cov8" title="1">{
                return Pad(str, length)
        }</span> else<span class="cov8" title="1"> if length &lt;= 7 </span><span class="cov0" title="0">{
                return string(runeStr[0:length])
        }</span>
        <span class="cov8" title="1">remaining := length - 5
        right := remaining / 2
        left := remaining - right
        firstPart := string(runeStr[0:left])
        lastPart := string(runeStr[strLen-right : strLen])
        if len(lastPart) &gt; 0 </span><span class="cov8" title="1">{
                return firstPart + ` ... ` + lastPart
        }</span>
        <span class="cov0" title="0">return firstPart</span>
}

//
// Rune Utilities - Functions for comparing rune slices
//

// RunesMatch returns true if two rune slices are equal.
func RunesMatch(a, b []rune) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range a </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// RunesNoMatch returns true if two rune slices are not equal.
func RunesNoMatch(a, b []rune) bool <span class="cov8" title="1">{
        return !RunesMatch(a, b)
}</span>

//
// Helper functions
//

func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func minInt(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package tokenizer

import (
        "fmt"
        "strings"
)

//
// Token - Token representation and tokenizer implementation
//

// Token represents a parsed token with its type, value, and position information.
type Token struct {
        kind   string
        value  []rune
        offset int
        row    int
        column int
}

// NewToken constructs a new Token with the given kind and value.
// Position fields (offset, row, column) are initialized to -1.
func NewToken(kind string, value []rune) *Token <span class="cov8" title="1">{
        return &amp;Token{kind, value, -1, -1, -1}
}</span>

// Kind returns the token's type/kind.
func (t *Token) Kind() string <span class="cov8" title="1">{
        return t.kind
}</span>

// Value returns the token's value as a slice of runes.
func (t *Token) Value() []rune <span class="cov8" title="1">{
        return t.value
}</span>

// ValueString returns the token's value as a string.
func (t *Token) ValueString() string <span class="cov8" title="1">{
        return string(t.value)
}</span>

// Offset returns the token's byte offset in the source.
func (t *Token) Offset() int <span class="cov8" title="1">{
        return t.offset
}</span>

// Row returns the token's line number (1-indexed).
func (t *Token) Row() int <span class="cov8" title="1">{
        return t.row
}</span>

// Column returns the token's column number (1-indexed).
func (t *Token) Column() int <span class="cov8" title="1">{
        return t.column
}</span>

// String returns a string representation of the token.
func (t *Token) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("[%s: %q]", t.kind, string(t.value))
}</span>

// Matcher is a function type that attempts to match and return a token from a stream.
// Returns nil if no match is found.
type Matcher func(stream Stream) *Token

//
// Tokenizer - Main tokenizer implementation
//

// Tokenizer processes a stream using a set of matchers to produce tokens.
// It automatically handles whitespace and supports backtracking.
type Tokenizer struct {
        matchers []Matcher
        stream   Stream
        marks    []Stream // stack of marked positions for rewinding
}

// NewTokenizer constructs a Tokenizer with the given matchers.
// WhiteSpaceMatcher is automatically prepended to consume whitespace.
func NewTokenizer(matchers ...Matcher) Tokenizer <span class="cov8" title="1">{
        newMatchers := make([]Matcher, 0)
        newMatchers = append(newMatchers, WhiteSpaceMatcher)
        newMatchers = append(newMatchers, matchers...)
        return Tokenizer{
                matchers: newMatchers,
                marks:    make([]Stream, 0),
        }
}</span>

// Initialize initializes the tokenizer with the given input string.
func (t *Tokenizer) Initialize(input string) <span class="cov8" title="1">{
        t.stream = NewStream(input)
}</span>

// Mark pushes the current stream position onto the marks stack for later rewinding.
func (t *Tokenizer) Mark() <span class="cov8" title="1">{
        t.marks = append(t.marks, t.stream.Clone())
}</span>

// Rewind restores the stream to the most recently marked position.
// Returns false if there are no marks to rewind to.
func (t *Tokenizer) Rewind() bool <span class="cov8" title="1">{
        if len(t.marks) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">lastIdx := len(t.marks) - 1
        marked := t.marks[lastIdx]
        t.marks = t.marks[:lastIdx] // pop the mark
        t.stream.Match(marked)
        return true</span>
}

// Tokenize applies NextToken until the end of stream or until a token cannot be read.
// Returns:
// - A slice of tokens
// - true if the stream was fully consumed (EOS reached)
func (t *Tokenizer) Tokenize() ([]Token, bool) <span class="cov8" title="1">{
        tokens := make([]Token, 0)
        for </span><span class="cov8" title="1">{
                token, ok := t.NextToken()
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">tokens = append(tokens, *token)</span>
        }
        <span class="cov8" title="1">return tokens, t.stream.IsEos()</span>
}

// TokenizeToString tokenizes the input and returns a debug string representation.
func (t *Tokenizer) TokenizeToString(separator string) string <span class="cov8" title="1">{
        tokens, eos := t.Tokenize()
        var sb strings.Builder
        for _, token := range tokens </span><span class="cov8" title="1">{
                sb.WriteString(token.String())
                if len(separator) &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString(separator)
                }</span>
        }
        <span class="cov8" title="1">if eos </span><span class="cov8" title="1">{
                sb.WriteString(`[EOS]`)
        }</span> else<span class="cov8" title="1"> {
                sb.WriteString(`[Stream...]`)
        }</span>
        <span class="cov8" title="1">return sb.String()</span>
}

// NextToken applies each matcher in order and returns the first successful token.
// The stream is advanced by the token's length.
// Returns nil, false if no matcher succeeds.
func (t *Tokenizer) NextToken() (*Token, bool) <span class="cov8" title="1">{
        if !t.hasMoreTokens() </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">offset := t.stream.GetOffset()
        row := t.stream.GetRow()
        column := t.stream.GetColumn()

        for _, matcher := range t.matchers </span><span class="cov8" title="1">{
                cs := t.stream.Clone()
                token := matcher(cs)
                if token != nil &amp;&amp; t.stream.MatchChars(token.value) </span><span class="cov8" title="1">{
                        token.offset = offset
                        token.row = row
                        token.column = column
                        return token, true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

// PeekToken applies each matcher in order and returns the first successful token
// without advancing the stream.
// Returns nil, false if no matcher succeeds.
func (t *Tokenizer) PeekToken() (*Token, bool) <span class="cov8" title="1">{
        if !t.hasMoreTokens() </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">for _, matcher := range t.matchers </span><span class="cov8" title="1">{
                cs := t.stream.Clone()
                token := matcher(cs)
                if token != nil &amp;&amp; t.stream.MatchChars(token.value) </span><span class="cov0" title="0">{
                        return token, true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

// GetRow returns the current stream row position.
func (t *Tokenizer) GetRow() int <span class="cov8" title="1">{
        return t.stream.GetRow()
}</span>

// GetColumn returns the current stream column position.
func (t *Tokenizer) GetColumn() int <span class="cov8" title="1">{
        return t.stream.GetColumn()
}</span>

// hasMoreTokens returns true if the stream is not at end.
func (t *Tokenizer) hasMoreTokens() bool <span class="cov8" title="1">{
        return !t.stream.IsEos()
}</span>

// reset resets the stream to the beginning and clears the marks stack.
func (t *Tokenizer) reset() <span class="cov0" title="0">{
        t.stream.Reset()
        t.marks = t.marks[:0]
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package ast

import "fmt"

// ArrayNode represents array validation with element schema.
type ArrayNode struct {
        elementSchema SchemaNode // Schema for all array elements
        position      Position
}

// NewArrayNode creates a new array node.
func NewArrayNode(elementSchema SchemaNode, pos Position) *ArrayNode <span class="cov8" title="1">{
        return &amp;ArrayNode{
                elementSchema: elementSchema,
                position:      pos,
        }
}</span>

// Type returns NodeTypeArray.
func (n *ArrayNode) Type() NodeType <span class="cov8" title="1">{
        return NodeTypeArray
}</span>

// ElementSchema returns the element schema.
func (n *ArrayNode) ElementSchema() SchemaNode <span class="cov8" title="1">{
        return n.elementSchema
}</span>

// Position returns the source position.
func (n *ArrayNode) Position() Position <span class="cov8" title="1">{
        return n.position
}</span>

// Accept implements the visitor pattern.
func (n *ArrayNode) Accept(visitor Visitor) error <span class="cov8" title="1">{
        return visitor.VisitArray(n)
}</span>

// String returns a string representation.
func (n *ArrayNode) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("[%s]", n.elementSchema.String())
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package ast

import (
        "fmt"
        "strings"
)

// FunctionNode represents function-based validation with arguments.
// Examples: Integer(1, 100), String(5+), Enum("M", "F", "O")
type FunctionNode struct {
        name      string        // Function name (Integer, String, Enum, etc.)
        arguments []interface{} // Arguments (literals or special symbols like "+")
        position  Position
}

// NewFunctionNode creates a new function node.
func NewFunctionNode(name string, arguments []interface{}, pos Position) *FunctionNode <span class="cov8" title="1">{
        return &amp;FunctionNode{
                name:      name,
                arguments: arguments,
                position:  pos,
        }
}</span>

// Type returns NodeTypeFunction.
func (n *FunctionNode) Type() NodeType <span class="cov8" title="1">{
        return NodeTypeFunction
}</span>

// Name returns the function name.
func (n *FunctionNode) Name() string <span class="cov8" title="1">{
        return n.name
}</span>

// Arguments returns the function arguments.
func (n *FunctionNode) Arguments() []interface{} <span class="cov8" title="1">{
        return n.arguments
}</span>

// Position returns the source position.
func (n *FunctionNode) Position() Position <span class="cov8" title="1">{
        return n.position
}</span>

// Accept implements the visitor pattern.
func (n *FunctionNode) Accept(visitor Visitor) error <span class="cov8" title="1">{
        return visitor.VisitFunction(n)
}</span>

// String returns a string representation.
func (n *FunctionNode) String() string <span class="cov8" title="1">{
        args := make([]string, len(n.arguments))
        for i, arg := range n.arguments </span><span class="cov8" title="1">{
                switch v := arg.(type) </span>{
                case string:<span class="cov8" title="1">
                        // Check if it's a special symbol
                        if v == "+" </span><span class="cov8" title="1">{
                                args[i] = v
                        }</span> else<span class="cov0" title="0"> {
                                args[i] = fmt.Sprintf("%q", v)
                        }</span>
                case nil:<span class="cov0" title="0">
                        args[i] = "null"</span>
                case bool:<span class="cov0" title="0">
                        args[i] = fmt.Sprintf("%t", v)</span>
                case int64:<span class="cov8" title="1">
                        args[i] = fmt.Sprintf("%d", v)</span>
                case float64:<span class="cov0" title="0">
                        args[i] = fmt.Sprintf("%g", v)</span>
                default:<span class="cov0" title="0">
                        args[i] = fmt.Sprintf("%v", v)</span>
                }
        }
        <span class="cov8" title="1">return fmt.Sprintf("%s(%s)", n.name, strings.Join(args, ", "))</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ast

import "fmt"

// LiteralNode represents an exact match validation (literal values from JSON/XML/etc.).
type LiteralNode struct {
        value    interface{} // string, int64, float64, bool, or nil
        position Position
}

// NewLiteralNode creates a new literal node.
func NewLiteralNode(value interface{}, pos Position) *LiteralNode <span class="cov8" title="1">{
        return &amp;LiteralNode{
                value:    value,
                position: pos,
        }
}</span>

// Type returns NodeTypeLiteral.
func (n *LiteralNode) Type() NodeType <span class="cov8" title="1">{
        return NodeTypeLiteral
}</span>

// Value returns the literal value.
func (n *LiteralNode) Value() interface{} <span class="cov8" title="1">{
        return n.value
}</span>

// Position returns the source position.
func (n *LiteralNode) Position() Position <span class="cov8" title="1">{
        return n.position
}</span>

// Accept implements the visitor pattern.
func (n *LiteralNode) Accept(visitor Visitor) error <span class="cov8" title="1">{
        return visitor.VisitLiteral(n)
}</span>

// String returns a string representation.
func (n *LiteralNode) String() string <span class="cov8" title="1">{
        switch v := n.value.(type) </span>{
        case nil:<span class="cov8" title="1">
                return "null"</span>
        case string:<span class="cov8" title="1">
                return fmt.Sprintf("%q", v)</span>
        case bool:<span class="cov8" title="1">
                return fmt.Sprintf("%t", v)</span>
        case int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v)</span>
        case float64:<span class="cov8" title="1">
                return fmt.Sprintf("%g", v)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v)</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package ast

import (
        "fmt"
        "sort"
        "strings"
)

// ObjectNode represents object/map validation with property schemas.
type ObjectNode struct {
        properties map[string]SchemaNode // Property name  schema
        position   Position
}

// NewObjectNode creates a new object node.
func NewObjectNode(properties map[string]SchemaNode, pos Position) *ObjectNode <span class="cov8" title="1">{
        return &amp;ObjectNode{
                properties: properties,
                position:   pos,
        }
}</span>

// Type returns NodeTypeObject.
func (n *ObjectNode) Type() NodeType <span class="cov8" title="1">{
        return NodeTypeObject
}</span>

// Properties returns the property schemas.
func (n *ObjectNode) Properties() map[string]SchemaNode <span class="cov8" title="1">{
        return n.properties
}</span>

// GetProperty returns the schema for a specific property.
func (n *ObjectNode) GetProperty(name string) (SchemaNode, bool) <span class="cov8" title="1">{
        node, ok := n.properties[name]
        return node, ok
}</span>

// Position returns the source position.
func (n *ObjectNode) Position() Position <span class="cov8" title="1">{
        return n.position
}</span>

// Accept implements the visitor pattern.
func (n *ObjectNode) Accept(visitor Visitor) error <span class="cov8" title="1">{
        return visitor.VisitObject(n)
}</span>

// String returns a string representation.
func (n *ObjectNode) String() string <span class="cov8" title="1">{
        if len(n.properties) == 0 </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        // Sort keys for deterministic output
        <span class="cov0" title="0">keys := make([]string, 0, len(n.properties))
        for k := range n.properties </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        parts := make([]string, len(keys))
        for i, k := range keys </span><span class="cov0" title="0">{
                parts[i] = fmt.Sprintf("%q: %s", k, n.properties[k].String())
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("{%s}", strings.Join(parts, ", "))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ast

import "fmt"

// Position represents a location in the source text.
type Position struct {
        Offset int // Byte offset (0-indexed)
        Line   int // Line number (1-indexed)
        Column int // Column number (1-indexed)
}

// NewPosition creates a new Position with the given offset, line, and column.
func NewPosition(offset, line, column int) Position <span class="cov8" title="1">{
        return Position{
                Offset: offset,
                Line:   line,
                Column: column,
        }
}</span>

// IsValid returns true if the position has been set (not default zero values).
func (p Position) IsValid() bool <span class="cov8" title="1">{
        return p.Line &gt; 0 &amp;&amp; p.Column &gt; 0
}</span>

// String returns a string representation of the position.
func (p Position) String() string <span class="cov8" title="1">{
        if !p.IsValid() </span><span class="cov8" title="1">{
                return "&lt;unknown position&gt;"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("line %d, column %d", p.Line, p.Column)</span>
}

// ZeroPosition returns a zero/invalid position.
func ZeroPosition() Position <span class="cov8" title="1">{
        return Position{Offset: 0, Line: 0, Column: 0}
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package ast

import (
        "fmt"
        "sort"
        "strings"
)

// PrettyPrint returns a human-readable, indented representation of the AST.
func PrettyPrint(node SchemaNode) string <span class="cov8" title="1">{
        return prettyPrint(node, 0)
}</span>

func prettyPrint(node SchemaNode, indent int) string <span class="cov8" title="1">{
        prefix := strings.Repeat("  ", indent)

        switch n := node.(type) </span>{
        case *LiteralNode:<span class="cov8" title="1">
                return fmt.Sprintf("%sLiteral: %s", prefix, n.String())</span>

        case *TypeNode:<span class="cov8" title="1">
                return fmt.Sprintf("%sType: %s", prefix, n.typeName)</span>

        case *FunctionNode:<span class="cov8" title="1">
                args := make([]string, len(n.arguments))
                for i, arg := range n.arguments </span><span class="cov8" title="1">{
                        switch v := arg.(type) </span>{
                        case string:<span class="cov0" title="0">
                                if v == "+" </span><span class="cov0" title="0">{
                                        args[i] = v
                                }</span> else<span class="cov0" title="0"> {
                                        args[i] = fmt.Sprintf("%q", v)
                                }</span>
                        case nil:<span class="cov0" title="0">
                                args[i] = "null"</span>
                        default:<span class="cov8" title="1">
                                args[i] = fmt.Sprintf("%v", v)</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Sprintf("%sFunction: %s(%s)", prefix, n.name, strings.Join(args, ", "))</span>

        case *ObjectNode:<span class="cov8" title="1">
                if len(n.properties) == 0 </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%sObject: {}", prefix)
                }</span>

                // Sort keys for deterministic output
                <span class="cov8" title="1">keys := make([]string, 0, len(n.properties))
                for k := range n.properties </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                lines := []string{fmt.Sprintf("%sObject:", prefix)}
                for _, k := range keys </span><span class="cov8" title="1">{
                        childStr := prettyPrint(n.properties[k], indent+1)
                        lines = append(lines, fmt.Sprintf("%s  %q:", prefix, k))
                        lines = append(lines, childStr)
                }</span>
                <span class="cov8" title="1">return strings.Join(lines, "\n")</span>

        case *ArrayNode:<span class="cov8" title="1">
                lines := []string{fmt.Sprintf("%sArray:", prefix)}
                lines = append(lines, fmt.Sprintf("%s  element:", prefix))
                lines = append(lines, prettyPrint(n.elementSchema, indent+2))
                return strings.Join(lines, "\n")</span>

        default:<span class="cov0" title="0">
                return fmt.Sprintf("%sUnknown node type", prefix)</span>
        }
}

// TreePrint returns a tree-style representation of the AST.
func TreePrint(node SchemaNode) string <span class="cov8" title="1">{
        return treePrint(node, "", true)
}</span>

func treePrint(node SchemaNode, prefix string, isLast bool) string <span class="cov8" title="1">{
        connector := " "
        if !isLast </span><span class="cov0" title="0">{
                connector = " "
        }</span>

        <span class="cov8" title="1">var result strings.Builder
        result.WriteString(prefix)
        result.WriteString(connector)

        switch n := node.(type) </span>{
        case *LiteralNode:<span class="cov0" title="0">
                result.WriteString(fmt.Sprintf("Literal: %s\n", n.String()))</span>

        case *TypeNode:<span class="cov8" title="1">
                result.WriteString(fmt.Sprintf("Type: %s\n", n.typeName))</span>

        case *FunctionNode:<span class="cov0" title="0">
                result.WriteString(fmt.Sprintf("Function: %s\n", n.String()))</span>

        case *ObjectNode:<span class="cov8" title="1">
                result.WriteString("Object\n")

                // Sort keys
                keys := make([]string, 0, len(n.properties))
                for k := range n.properties </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                childPrefix := prefix
                if isLast </span><span class="cov8" title="1">{
                        childPrefix += "    "
                }</span> else<span class="cov0" title="0"> {
                        childPrefix += "   "
                }</span>

                <span class="cov8" title="1">for i, k := range keys </span><span class="cov8" title="1">{
                        result.WriteString(childPrefix)
                        if i == len(keys)-1 </span><span class="cov8" title="1">{
                                result.WriteString(" ")
                        }</span> else<span class="cov0" title="0"> {
                                result.WriteString(" ")
                        }</span>
                        <span class="cov8" title="1">result.WriteString(fmt.Sprintf("%q:\n", k))

                        grandChildPrefix := childPrefix
                        if i == len(keys)-1 </span><span class="cov8" title="1">{
                                grandChildPrefix += "    "
                        }</span> else<span class="cov0" title="0"> {
                                grandChildPrefix += "   "
                        }</span>

                        <span class="cov8" title="1">result.WriteString(treePrint(n.properties[k], grandChildPrefix, true))</span>
                }

        case *ArrayNode:<span class="cov0" title="0">
                result.WriteString("Array\n")

                childPrefix := prefix
                if isLast </span><span class="cov0" title="0">{
                        childPrefix += "    "
                }</span> else<span class="cov0" title="0"> {
                        childPrefix += "   "
                }</span>

                <span class="cov0" title="0">result.WriteString(treePrint(n.elementSchema, childPrefix, true))</span>

        default:<span class="cov0" title="0">
                result.WriteString("Unknown\n")</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package ast

import (
        "encoding/json"
        "fmt"
)

// SerializableNode is a helper struct for JSON serialization.
type SerializableNode struct {
        Type       string                 `json:"type"`
        Value      interface{}            `json:"value,omitempty"`
        TypeName   string                 `json:"typeName,omitempty"`
        Name       string                 `json:"name,omitempty"`
        Arguments  []interface{}          `json:"arguments,omitempty"`
        Properties map[string]interface{} `json:"properties,omitempty"`
        Element    interface{}            `json:"element,omitempty"`
        Position   *Position              `json:"position,omitempty"`
}

// MarshalJSON implements json.Marshaler for LiteralNode.
func (n *LiteralNode) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;SerializableNode{
                Type:     "literal",
                Value:    n.value,
                Position: &amp;n.position,
        })
}</span>

// MarshalJSON implements json.Marshaler for TypeNode.
func (n *TypeNode) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;SerializableNode{
                Type:     "type",
                TypeName: n.typeName,
                Position: &amp;n.position,
        })
}</span>

// MarshalJSON implements json.Marshaler for FunctionNode.
func (n *FunctionNode) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;SerializableNode{
                Type:      "function",
                Name:      n.name,
                Arguments: n.arguments,
                Position:  &amp;n.position,
        })
}</span>

// MarshalJSON implements json.Marshaler for ObjectNode.
func (n *ObjectNode) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        props := make(map[string]interface{})
        for k, v := range n.properties </span><span class="cov8" title="1">{
                props[k] = v
        }</span>

        <span class="cov8" title="1">return json.Marshal(&amp;SerializableNode{
                Type:       "object",
                Properties: props,
                Position:   &amp;n.position,
        })</span>
}

// MarshalJSON implements json.Marshaler for ArrayNode.
func (n *ArrayNode) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;SerializableNode{
                Type:     "array",
                Element:  n.elementSchema,
                Position: &amp;n.position,
        })
}</span>

// UnmarshalSchemaNode unmarshals JSON into a SchemaNode.
func UnmarshalSchemaNode(data []byte) (SchemaNode, error) <span class="cov8" title="1">{
        var sn SerializableNode
        if err := json.Unmarshal(data, &amp;sn); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pos := ZeroPosition()
        if sn.Position != nil </span><span class="cov8" title="1">{
                pos = *sn.Position
        }</span>

        <span class="cov8" title="1">switch sn.Type </span>{
        case "literal":<span class="cov8" title="1">
                return NewLiteralNode(sn.Value, pos), nil</span>

        case "type":<span class="cov8" title="1">
                return NewTypeNode(sn.TypeName, pos), nil</span>

        case "function":<span class="cov8" title="1">
                return NewFunctionNode(sn.Name, sn.Arguments, pos), nil</span>

        case "object":<span class="cov8" title="1">
                props := make(map[string]SchemaNode)
                for k, v := range sn.Properties </span><span class="cov8" title="1">{
                        vBytes, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to marshal property %q: %w", k, err)
                        }</span>

                        <span class="cov8" title="1">node, err := UnmarshalSchemaNode(vBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to unmarshal property %q: %w", k, err)
                        }</span>

                        <span class="cov8" title="1">props[k] = node</span>
                }
                <span class="cov8" title="1">return NewObjectNode(props, pos), nil</span>

        case "array":<span class="cov8" title="1">
                elemBytes, err := json.Marshal(sn.Element)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal array element: %w", err)
                }</span>

                <span class="cov8" title="1">elemNode, err := UnmarshalSchemaNode(elemBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal array element: %w", err)
                }</span>

                <span class="cov8" title="1">return NewArrayNode(elemNode, pos), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown node type: %q", sn.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package ast

// TypeNode represents type validation (built-in type identifiers like UUID, Email, etc.).
type TypeNode struct {
        typeName string // "UUID", "Email", "ISO-8601", etc.
        position Position
}

// NewTypeNode creates a new type node.
func NewTypeNode(typeName string, pos Position) *TypeNode <span class="cov8" title="1">{
        return &amp;TypeNode{
                typeName: typeName,
                position: pos,
        }
}</span>

// Type returns NodeTypeType.
func (n *TypeNode) Type() NodeType <span class="cov8" title="1">{
        return NodeTypeType
}</span>

// TypeName returns the type identifier name.
func (n *TypeNode) TypeName() string <span class="cov8" title="1">{
        return n.typeName
}</span>

// Position returns the source position.
func (n *TypeNode) Position() Position <span class="cov8" title="1">{
        return n.position
}</span>

// Accept implements the visitor pattern.
func (n *TypeNode) Accept(visitor Visitor) error <span class="cov8" title="1">{
        return visitor.VisitType(n)
}</span>

// String returns a string representation.
func (n *TypeNode) String() string <span class="cov8" title="1">{
        return n.typeName
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package ast

// NodeType represents the type of an AST node.
type NodeType int

const (
        // NodeTypeLiteral represents a literal value (string, number, bool, null)
        NodeTypeLiteral NodeType = iota

        // NodeTypeType represents a type identifier (UUID, Email, ISO-8601, etc.)
        NodeTypeType

        // NodeTypeFunction represents a function call (Integer(1, 100), String(5+), etc.)
        NodeTypeFunction

        // NodeTypeObject represents an object with properties
        NodeTypeObject

        // NodeTypeArray represents an array with element schema
        NodeTypeArray
)

// String returns the string representation of the node type.
func (nt NodeType) String() string <span class="cov8" title="1">{
        switch nt </span>{
        case NodeTypeLiteral:<span class="cov8" title="1">
                return "Literal"</span>
        case NodeTypeType:<span class="cov8" title="1">
                return "Type"</span>
        case NodeTypeFunction:<span class="cov8" title="1">
                return "Function"</span>
        case NodeTypeObject:<span class="cov8" title="1">
                return "Object"</span>
        case NodeTypeArray:<span class="cov8" title="1">
                return "Array"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package ast

// Visitor is the interface for traversing the AST using the visitor pattern.
type Visitor interface {
        VisitLiteral(node *LiteralNode) error
        VisitType(node *TypeNode) error
        VisitFunction(node *FunctionNode) error
        VisitObject(node *ObjectNode) error
        VisitArray(node *ArrayNode) error
}

// BaseVisitor provides default implementations for the Visitor interface.
// Embed this in your visitor to only override the methods you need.
type BaseVisitor struct{}

// VisitLiteral is the default implementation for visiting literal nodes.
func (v *BaseVisitor) VisitLiteral(node *LiteralNode) error <span class="cov0" title="0">{
        return nil
}</span>

// VisitType is the default implementation for visiting type nodes.
func (v *BaseVisitor) VisitType(node *TypeNode) error <span class="cov0" title="0">{
        return nil
}</span>

// VisitFunction is the default implementation for visiting function nodes.
func (v *BaseVisitor) VisitFunction(node *FunctionNode) error <span class="cov0" title="0">{
        return nil
}</span>

// VisitObject is the default implementation for visiting object nodes.
func (v *BaseVisitor) VisitObject(node *ObjectNode) error <span class="cov0" title="0">{
        return nil
}</span>

// VisitArray is the default implementation for visiting array nodes.
func (v *BaseVisitor) VisitArray(node *ArrayNode) error <span class="cov0" title="0">{
        return nil
}</span>

// Walk traverses the AST starting from the given node using the provided visitor.
func Walk(node SchemaNode, visitor Visitor) error <span class="cov8" title="1">{
        return node.Accept(visitor)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Package shape provides a multi-format validation schema parser.
// It converts validation schema formats (JSONV, XMLV, PropsV, etc.) into a unified AST representation.
package shape

import (
        "fmt"

        "github.com/shapestone/shape/internal/parser"
        "github.com/shapestone/shape/internal/parser/jsonv"
        "github.com/shapestone/shape/pkg/ast"
)

// Parse parses input with an explicit format.
// Returns the parsed AST or an error if parsing fails.
//
// Example:
//
//        node, err := shape.Parse(parser.FormatJSONV, `{"id": UUID}`)
//        if err != nil {
//            log.Fatal(err)
//        }
func Parse(format parser.Format, input string) (ast.SchemaNode, error) <span class="cov8" title="1">{
        p, err := newParser(format)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return p.Parse(input)</span>
}

// newParser creates a parser for the specified format.
func newParser(format parser.Format) (parser.Parser, error) <span class="cov8" title="1">{
        switch format </span>{
        case parser.FormatJSONV:<span class="cov8" title="1">
                return jsonv.NewParser(), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported format: %v", format)</span>
        }
}

// ParseAuto auto-detects the format and parses the input.
// Returns the parsed AST, the detected format, and any error.
//
// Example:
//
//        node, format, err := shape.ParseAuto(`{"id": UUID}`)
//        if err != nil {
//            log.Fatal(err)
//        }
//        fmt.Printf("Detected format: %s\n", format)
func ParseAuto(input string) (ast.SchemaNode, parser.Format, error) <span class="cov8" title="1">{
        format, err := parser.DetectFormat(input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, parser.FormatUnknown, err
        }</span>

        <span class="cov8" title="1">node, err := Parse(format, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, format, err
        }</span>

        <span class="cov8" title="1">return node, format, nil</span>
}

// MustParse parses or panics (useful for tests and initialization).
// Use this only when you're certain the input is valid.
//
// Example:
//
//        node := shape.MustParse(parser.FormatJSONV, `{"id": UUID}`)
func MustParse(format parser.Format, input string) ast.SchemaNode <span class="cov8" title="1">{
        node, err := Parse(format, input)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return node</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
